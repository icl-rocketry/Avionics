Copyright (c) 20011-\/2018 Bill Greiman This file is part of the \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}} library for SD memory cards.

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \char`\"{}\+Software\char`\"{}), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions\+:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED \char`\"{}\+AS IS\char`\"{}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

\begin{center}Copyright \&copy 2012-\/2018 by William Greiman \end{center} \hypertarget{index_Intro}{}\doxysection{Introduction}\label{index_Intro}
The Arduino Sd\+Fat Library is a minimal implementation of FAT16 and FAT32 file systems on SD flash memory cards. Standard SD and high capacity SDHC cards are supported.

Experimental support for FAT12 can be enabled by setting FAT12\+\_\+\+SUPPORT nonzero in \mbox{\hyperlink{_sd_fat_config_8h}{Sd\+Fat\+Config.\+h}}.

The Sd\+Fat library supports Long File Names or short 8.\+3 names. Edit the \mbox{\hyperlink{_sd_fat_config_8h}{Sd\+Fat\+Config.\+h}} file to select short or long file names.

The main classes in Sd\+Fat are \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}}, Sd\+Fat\+EX, Sd\+Fat\+Soft\+Spi, Sd\+Fat\+Soft\+Spi\+EX, \mbox{\hyperlink{class_sd_base_file}{Sd\+Base\+File}}, Sd\+File, File, \mbox{\hyperlink{class_stdio_stream}{Stdio\+Stream}}, \mbox{\hyperlink{classfstream}{fstream}}, \mbox{\hyperlink{classifstream}{ifstream}}, and \mbox{\hyperlink{classofstream}{ofstream}}.

The \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}}, Sd\+Fat\+EX, Sd\+Fat\+Soft\+Spi and Sd\+Fat\+Soft\+Spi\+EX classes maintain a FAT volume, a current working directory, and simplify initialization of other classes. The \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}} and Sd\+Fat\+EX classes uses a fast custom hardware SPI implementation. The Sd\+Fat\+Soft\+Spi and Sd\+Fat\+Soft\+Spi\+EX classes uses software SPI.

the Sd\+Fat\+EX and Sd\+Fat\+Soft\+Spi\+EX use extended multi-\/block I/O for enhanced performance. These classes must have exclusive use of the SPI bus.

The \mbox{\hyperlink{class_sd_base_file}{Sd\+Base\+File}} class provides basic file access functions such as open(), binary read(), binary write(), close(), remove(), and sync(). \mbox{\hyperlink{class_sd_base_file}{Sd\+Base\+File}} is the smallest file class.

The Sd\+File class has all the \mbox{\hyperlink{class_sd_base_file}{Sd\+Base\+File}} class functions plus the Arduino Print class functions.

The File class has all the \mbox{\hyperlink{class_sd_base_file}{Sd\+Base\+File}} functions plus the functions in the Arduino SD.\+h File class. This provides compatibility with the Arduino SD.\+h library.

The \mbox{\hyperlink{class_stdio_stream}{Stdio\+Stream}} class implements functions similar to Linux/\+Unix standard buffered input/output.

The \mbox{\hyperlink{classfstream}{fstream}} class implements C++ iostreams for both reading and writing text files.

The \mbox{\hyperlink{classifstream}{ifstream}} class implements C++ iostreams for reading text files.

The \mbox{\hyperlink{classofstream}{ofstream}} class implements C++ iostreams for writing text files.

The classes \mbox{\hyperlink{classifstream}{ifstream}}, \mbox{\hyperlink{classofstream}{ofstream}}, \mbox{\hyperlink{classistream}{istream}}, and \mbox{\hyperlink{classostream}{ostream}} follow the C++ \mbox{\hyperlink{classiostream}{iostream}} standard when possible.

There are many tutorials and much documentation about using C++ iostreams on the web.

\href{http://www.cplusplus.com/}{\texttt{ http\+://www.\+cplusplus.\+com/}} is a good C++ site for learning iostreams.

The classes \mbox{\hyperlink{classibufstream}{ibufstream}} and \mbox{\hyperlink{classobufstream}{obufstream}} format and parse character strings in memory buffers.

the classes Arduino\+In\+Stream and Arduino\+Out\+Stream provide iostream functions for Serial, Liquid\+Crystal, and other devices.

A number of example are provided in the Sd\+Fat/examples folder. These were developed to test Sd\+Fat and illustrate its use.\hypertarget{index_Install}{}\doxysection{Installation}\label{index_Install}
You must manually install \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}} by copying the \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}} folder from the download package to the Arduino libraries folder in your sketch folder.

See the Manual installation section of this guide.

\href{http://arduino.cc/en/Guide/Libraries}{\texttt{ http\+://arduino.\+cc/en/\+Guide/\+Libraries}}\hypertarget{index_SDconfig}{}\doxysection{Sd\+Fat Configuration}\label{index_SDconfig}
Several configuration options may be changed by editing the \mbox{\hyperlink{_sd_fat_config_8h}{Sd\+Fat\+Config.\+h}} file in the Sd\+Fat folder.

Set USE\+\_\+\+LONG\+\_\+\+FILE\+\_\+\+NAMES nonzero to enable Long File Names. By default, Long File Names are enabled. For the leanest fastest library disable Long File Names. Long File names require extra flash but no extra RAM. Opening Long File Names can be slower than opening Short File Names. Data read and write performance is not changed by the type of File Name.

If the symbol ENABLE\+\_\+\+EXTENDED\+\_\+\+TRANSFER\+\_\+\+CLASS is nonzero, the class Sd\+Fat\+EX will be defined. If the symbol ENABLE\+\_\+\+SOFTWARE\+\_\+\+SPI\+\_\+\+CLASS is also nonzero, the class Sd\+Fat\+Soft\+Spi\+EX will be defined. These classes used extended multi-\/block SD I/O for better performance. the SPI bus may not be shared with other devices in this mode.

Set USE\+\_\+\+STANDARD\+\_\+\+SPI\+\_\+\+LIBRARY and ENABLE\+\_\+\+SOFTWARE\+\_\+\+SPI\+\_\+\+CLASS to enable various SPI options. set USE\+\_\+\+STANDARD\+\_\+\+SPI\+\_\+\+LIBRARY to use the standard Arduino SPI library. set ENABLE\+\_\+\+SOFTWARE\+\_\+\+SPI\+\_\+\+CLASS to enable the Sd\+Fat\+Soft\+Spi class which uses software SPI.

To enable SD card CRC checking set USE\+\_\+\+SD\+\_\+\+CRC nonzero.

Set FAT12\+\_\+\+SUPPORT nonzero to enable use of FAT12 volumes. FAT12 has not been well tested and requires additional flash.\hypertarget{index_SDPath}{}\doxysection{Paths and Working Directories}\label{index_SDPath}
Relative paths in \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}} are resolved in a manner similar to Windows.

Each instance of \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}} has a current directory. In \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}} this directory is called the volume working directory, vwd. Initially this directory is the root directory for the volume.

The volume working directory is changed by calling Sd\+Fat\+::chdir(path).

The call sd.\+chdir(\char`\"{}/2014\char`\"{}) will change the volume working directory for sd to \char`\"{}/2014\char`\"{}, assuming \char`\"{}/2014\char`\"{} exists.

Relative paths for \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}} member functions are resolved by starting at the volume working directory.

For example, the call sd.\+mkdir(\char`\"{}\+April\char`\"{}) will create the directory \char`\"{}/2014/\+April\char`\"{} assuming the volume working directory is \char`\"{}/2014\char`\"{}.

\mbox{\hyperlink{class_sd_fat}{Sd\+Fat}} has a current working directory, cwd, that is used to resolve paths for file.\+open() calls.

For a single SD card the current working directory is always the volume working directory for that card.

For multiple SD cards the current working directory is set to the volume working directory of a card by calling the \mbox{\hyperlink{class_fat_file_system_af24917d6e00c8766dab168eb834047ec}{Sd\+Fat\+::chvol()}} member function. The chvol() call is like the Windows $<$drive letter$>$\+: command.

The call sd2.\+chvol() will set the current working directory to the volume working directory for sd2.

If the volume working directory for sd2 is \char`\"{}/music\char`\"{} the call

file.\+open(\char`\"{}\+Big\+Band.\+wav\char`\"{}, O\+\_\+\+READ);

will then open \char`\"{}/music/\+Big\+Band.\+wav\char`\"{} on sd2.

The following functions are used to change or get current directories. See the html documentation for more information. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{bool} \mbox{\hyperlink{class_fat_file_system_a5667915e63187a43a71dfada63800865}{SdFat::chdir}}(\textcolor{keywordtype}{bool} set\_cwd = \textcolor{keyword}{false});}
\DoxyCodeLine{\textcolor{keywordtype}{bool} \mbox{\hyperlink{class_fat_file_system_a5667915e63187a43a71dfada63800865}{SdFat::chdir}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* path, \textcolor{keywordtype}{bool} set\_cwd = \textcolor{keyword}{false});}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{class_fat_file_system_af24917d6e00c8766dab168eb834047ec}{SdFat::chvol}}();}
\DoxyCodeLine{\mbox{\hyperlink{class_sd_base_file}{SdBaseFile}}* \mbox{\hyperlink{class_fat_file_system_acf257d02b7166683bda2abc5058004bf}{SdFat::vwd}}();}
\DoxyCodeLine{\textcolor{keyword}{static} \mbox{\hyperlink{class_sd_base_file}{SdBaseFile}}* \mbox{\hyperlink{class_fat_file_a3b68e603ad8e47bad915f0547e580adb}{SdBaseFile::cwd}}();}

\end{DoxyCode}
\hypertarget{index_SDcard}{}\doxysection{SD\textbackslash{}\+SDHC Cards}\label{index_SDcard}
Arduinos access SD cards using the cards SPI protocol. PCs, Macs, and most consumer devices use the 4-\/bit parallel SD protocol. A card that functions well on A PC or Mac may not work well on the Arduino.

Most cards have good SPI read performance but cards vary widely in SPI write performance. Write performance is limited by how efficiently the card manages internal erase/remapping operations. The Arduino cannot optimize writes to reduce erase operations because of its limit RAM.

San\+Disk cards generally have good write performance. They seem to have more internal RAM buffering than other cards and therefore can limit the number of flash erase operations that the Arduino forces due to its limited RAM.\hypertarget{index_Hardware}{}\doxysection{Hardware Configuration}\label{index_Hardware}
Sd\+Fat was developed using an \href{http://www.adafruit.com/}{\texttt{ Adafruit Industries}} Data Logging Shield.

The hardware interface to the SD card should not use a resistor based level shifter. Sd\+Fat sets the SPI bus frequency to 8 MHz which results in signal rise times that are too slow for the edge detectors in many newer SD card controllers when resistor voltage dividers are used.

The 5 to 3.\+3 V level shifter for 5 V Arduinos should be IC based like the 74HC4050N based circuit shown in the file Sd\+Level.\+png. The Adafruit Wave Shield uses a 74AHC125N. Gravitech sells SD and Micro\+SD Card Adapters based on the 74LCX245.

If you are using a resistor based level shifter and are having problems try setting the SPI bus frequency to 4 MHz. This can be done by using card.\+init(\+SPI\+\_\+\+HALF\+\_\+\+SPEED) to initialize the SD card.

A feature to use software SPI is available. Software SPI is slower than hardware SPI but allows any digital pins to be used. See \mbox{\hyperlink{_sd_fat_config_8h}{Sd\+Fat\+Config.\+h}} for software SPI definitions.\hypertarget{index_comment}{}\doxysection{Bugs and Comments}\label{index_comment}
If you wish to report bugs or have comments, send email to \href{mailto:fat16lib@sbcglobal.net}{\texttt{ fat16lib@sbcglobal.\+net}}. If possible, include a simple program that illustrates the bug or problem.\hypertarget{index_Trouble}{}\doxysection{Troubleshooting}\label{index_Trouble}
The two example programs Quick\+Start, and Sd\+Info are useful for troubleshooting.

A message like this from Sd\+Info with error\+Code 0X1 indicates the SD card is not seen by \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}}. This is often caused by a wiring error and reformatting the card will not solve the problem. 
\begin{DoxyPre}
cardBegin failed
SD errorCode: 0X1
SD errorData: 0XFF
\end{DoxyPre}
 Here is a similar message from Quick\+Start\+: 
\begin{DoxyPre}
SD initialization failed.
Do not reformat the card!
Is the card correctly inserted?
Is chipSelect set to the correct value?
Does another SPI device need to be disabled?
Is there a wiring/soldering problem?

errorCode: 0x1, errorData: 0xff
\end{DoxyPre}
 Here is a message from Quick\+Start that indicates a formatting problem\+: 
\begin{DoxyPre}
Card successfully initialized.
Can't find a valid FAT16/FAT32 partition.
Try reformatting the card.  For best results use
the SdFormatter program in SdFat/examples or download
and use SDFormatter from www.sdcard.org/downloads.
\end{DoxyPre}


The best source of recent information and help is the Arduino forum.

\href{http://arduino.cc/forum/}{\texttt{ http\+://arduino.\+cc/forum/}}

Also search the Adafruit forum.

\href{http://forums.adafruit.com/}{\texttt{ http\+://forums.\+adafruit.\+com/}}

If you are using a Teensy try.

\href{http://forum.pjrc.com/forum.php}{\texttt{ http\+://forum.\+pjrc.\+com/forum.\+php}}\hypertarget{index_SdFatClass}{}\doxysection{Sd\+Fat Usage}\label{index_SdFatClass}
\mbox{\hyperlink{class_sd_fat}{Sd\+Fat}} supports Long File Names. Long names in \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}} are limited to 7-\/bit ASCII characters in the range 0X20 -\/ 0XFE The following are reserved characters\+: 
\begin{DoxyItemize}
\item $<$ (less than) 
\item $>$ (greater than) 
\item \+: (colon) 
\item "{} (double quote) 
\item / (forward slash) 
\item \textbackslash{} (backslash) 
\item $\vert$ (vertical bar or pipe) 
\item ? (question mark) 
\item $\ast$ (asterisk) 
\end{DoxyItemize}Sd\+Fat uses a slightly restricted form of short names. Short names are limited to 8 characters followed by an optional period (.) and extension of up to 3 characters. The characters may be any combination of letters and digits. The following special characters are also allowed\+:

\$ \% \textquotesingle{} -\/ \+\_\+ @ $\sim$ \`{} ! ( ) \{ \} $^\wedge$ \# \&

Short names are always converted to upper case and their original case value is lost. Files that have a base-\/name where all characters have the same case and an extension where all characters have the same case will display properly. Examples this type name are UPPER.\+low, lower.\+TXT, UPPER.\+TXT, and lower.\+txt.

An application which writes to a file using print(), println() or write() must close the file or call sync() at the appropriate time to force data and directory information to be written to the SD Card.

Applications must use care calling sync() since 2048 bytes of I/O is required to update file and directory information. This includes writing the current data block, reading the block that contains the directory entry for update, writing the directory block back and reading back the current data block.

It is possible to open a file with two or more instances of a file object. A file may be corrupted if data is written to the file by more than one instance of a file object.\hypertarget{index_HowTo}{}\doxysection{How to format SD Cards as FAT Volumes}\label{index_HowTo}
The best way to restore an SD card\textquotesingle{}s format on a PC or Mac is to use SDFormatter which can be downloaded from\+:

\href{http://www.sdcard.org/downloads}{\texttt{ http\+://www.\+sdcard.\+org/downloads}}

A formatter program, Sd\+Formatter.\+ino, is included in the Sd\+Fat/examples/\+Sd\+Formatter directory. This program attempts to emulate SD Association\textquotesingle{}s SDFormatter.

SDFormatter aligns flash erase boundaries with file system structures which reduces write latency and file system overhead.

The PC/\+Mac SDFormatter does not have an option for FAT type so it may format very small cards as FAT12. Use the \mbox{\hyperlink{class_sd_fat}{Sd\+Fat}} formatter to force FAT16 formatting of small cards.

Do not format the SD card with an OS utility, OS utilities do not format SD cards in conformance with the SD standard.

You should use a freshly formatted SD card for best performance. FAT file systems become slower if many files have been created and deleted. This is because the directory entry for a deleted file is marked as deleted, but is not deleted. When a new file is created, these entries must be scanned before creating the file. Also files can become fragmented which causes reads and writes to be slower.\hypertarget{index_ExampleFilder}{}\doxysection{Examples}\label{index_ExampleFilder}
A number of examples are provided in the Sd\+Fat/examples folder. See the html documentation for a list.

To access these examples from the Arduino development environment go to\+: File -\/$>$ Examples -\/$>$ Sd\+Fat -\/$>$ $<$program Name$>$

Compile, upload to your Arduino and click on Serial Monitor to run the example.

Here is a list\+:

Analog\+Bin\+Logger -\/ Fast AVR ADC logger -\/ see the Analog\+Bin\+Logger\+Extras folder.

bench -\/ A read/write benchmark.

data\+Logger -\/ A simple modifiable data logger.

Directory\+Functions -\/ Demo of chdir(), ls(), mkdir(), and rmdir().

fgets -\/ Demo of the fgets read line/string function.

formating -\/ Print a table with various formatting options.

getline -\/ Example of getline from section 27.\+7.\+1.\+3 of the C++ standard.

Long\+File\+Name -\/ Example use of open\+Next, print\+Name, and open by index.

Low\+Latency\+Logger -\/ A data logger for higher data rates. ADC version.

Low\+Latency\+Logger\+ADXL345 -\/ A data logger for higher data rates. ADXL345 SPI.

Low\+Latency\+Logger\+MPU6050 -\/ A data logger for higher data rates. MPU6050 I2C.

Open\+Next -\/ Open all files in the root dir and print their filename.

Print\+Benchmark -\/ A simple benchmark for printing to a text file.

Quick\+Start -\/ A program to quickly test your SD card and SD shield/module.

Raw\+Write -\/ A test of raw write functions for contiguous files.

Read\+Csv -\/ Function to read a CSV text file one field at a time.

Read\+Csv\+Stream -\/ Read a comma-\/separated value file using iostream extractors.

Read\+Csv\+Array -\/ Read a two dimensional array from a CSV file.

Read\+Write -\/ Compatibility test of Arduino SD Read\+Write example.

rename -\/ A demo of Sd\+Fat\+::rename(old, new) and Sd\+File\+::rename(dir\+File, new\+Path).

Sd\+Formatter -\/ This program will format an SD or SDHC card.

Software\+Spi -\/ Simple demonstration of the Sd\+Fat\+Soft\+Spi template class.

Sd\+Info -\/ Initialize an SD card and analyze its structure for trouble shooting.

Stdio\+Bench -\/ Demo and test of stdio style stream.

Timestamp -\/ Sets file create, modify, and access timestamps.

Two\+Cards -\/ Example using two SD cards.

Volume\+Free\+Space -\/ Demonstrate the free\+Cluster\+Count() call.

wipe -\/ Example to wipe all data from an already formatted SD. 